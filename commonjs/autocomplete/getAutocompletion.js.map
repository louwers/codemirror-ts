{"version":3,"file":"getAutocompletion.js","sourceRoot":"","sources":["../../../src/autocomplete/getAutocompletion.ts"],"names":[],"mappings":";;;AAKA,2CAA+C;AAE/C,6CAAsD;AACtD,yCAA2D;AAC3D,qDAA+C;AAE/C,MAAM,qBAAqB,GAAwB,CAAC,8BAAiB,CAAC,OAAO,CAAC,CAAC;AAExE,KAAK,UAAU,iBAAiB,CAAC,EACtC,GAAG,EACH,IAAI,EACJ,OAAO,GASR;IACC,MAAM,EAAE,GAAG,EAAE,QAAQ,EAAE,GAAG,OAAO,CAAC;IAClC,MAAM,WAAW,GAAG,GAAG,CAAC,aAAa,CAAC,IAAI,CAAC,EAAE,WAAW,EAAE,CAAC;IAE3D,IAAI,CAAC,WAAW;QAAE,OAAO,IAAI,CAAC;IAE9B,kEAAkE;IAClE,kDAAkD;IAClD,IAAI,IAAI,GAAG,IAAA,4BAAW,EAAC,WAAW,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;IAChD,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE;QACf,IAAI,GAAG,IAAA,4BAAW,EAAC,WAAW,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC;KAC5C;IAED,IAAI,CAAC,IAAI,EAAE,IAAI,IAAI,CAAC,QAAQ;QAAE,OAAO,IAAI,CAAC;IAE1C,MAAM,cAAc,GAAG,GAAG,CAAC,eAAe,CAAC,wBAAwB,CACjE,IAAI,EACJ,GAAG,EACH,EAAE,EACF,EAAE,CACH,CAAC;IAEF,gDAAgD;IAChD,gCAAgC;IAChC,IAAI,CAAC,cAAc;QAAE,OAAO,IAAI,CAAC;IAEjC,MAAM,OAAO,GAAG,cAAc,CAAC,OAAO;SACnC,MAAM,CACL,CAAC,KAAK,EAAE,EAAE,CACR,CAAC,qBAAqB,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC;QAC3C,CAAC,KAAK,CAAC,QAAQ,GAAG,IAAI;YACpB,CAAC,cAAc,CAAC,uBAAuB,EAAE,MAAM;gBAC7C,mCAAsB,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CACpD;SACA,GAAG,CAAC,CAAC,KAAK,EAAc,EAAE;QACzB,MAAM,KAAK,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QAC3C,IAAI,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;QAEvD,IAAI,IAAI,KAAK,QAAQ;YAAE,IAAI,GAAG,UAAU,CAAC;QAEzC,IAAI,IAAI,IAAI,CAAC,wCAA6B,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;YACpD,IAAI,GAAG,SAAS,CAAC;SAClB;QAED,OAAO;YACL,KAAK,EAAE,KAAK,CAAC,IAAI;YACjB,IAAI;YACJ,KAAK;SACN,CAAC;IACJ,CAAC,CAAC,CAAC;IAEL,OAAO;QACL,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,KAAK,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG;QAC5D,OAAO;KACR,CAAC;AACJ,CAAC;AAnED,8CAmEC","sourcesContent":["import type {\n  CompletionContext,\n  Completion,\n  CompletionResult,\n} from \"@codemirror/autocomplete\";\nimport { ScriptElementKind } from \"typescript\";\nimport { type VirtualTypeScriptEnvironment } from \"@typescript/vfs\";\nimport { AUTOCOMPLETION_SYMBOLS } from \"./symbols.js\";\nimport { DEFAULT_CODEMIRROR_TYPE_ICONS } from \"./icons.js\";\nimport { matchBefore } from \"./matchBefore.js\";\n\nconst TS_COMPLETE_BLOCKLIST: ScriptElementKind[] = [ScriptElementKind.warning];\n\nexport async function getAutocompletion({\n  env,\n  path,\n  context,\n}: {\n  env: VirtualTypeScriptEnvironment;\n  path: string;\n  /**\n   * Allow this to be a subset of the full CompletionContext\n   * object, because the raw object isn't serializable.\n   */\n  context: Pick<CompletionContext, \"pos\" | \"explicit\">;\n}): Promise<CompletionResult | null> {\n  const { pos, explicit } = context;\n  const rawContents = env.getSourceFile(path)?.getFullText();\n\n  if (!rawContents) return null;\n\n  // If there's space behind the cursor, don't try and autocomplete.\n  // https://codemirror.net/examples/autocompletion/\n  let word = matchBefore(rawContents, pos, /\\w*/);\n  if (!word?.text) {\n    word = matchBefore(rawContents, pos, /\\./);\n  }\n\n  if (!word?.text && !explicit) return null;\n\n  const completionInfo = env.languageService.getCompletionsAtPosition(\n    path,\n    pos,\n    {},\n    {},\n  );\n\n  // TODO: build ATA support for a 'loading' state\n  // while types are being fetched\n  if (!completionInfo) return null;\n\n  const options = completionInfo.entries\n    .filter(\n      (entry) =>\n        !TS_COMPLETE_BLOCKLIST.includes(entry.kind) &&\n        (entry.sortText < \"15\" ||\n          (completionInfo.optionalReplacementSpan?.length &&\n            AUTOCOMPLETION_SYMBOLS.includes(entry.name))),\n    )\n    .map((entry): Completion => {\n      const boost = -Number(entry.sortText) || 0;\n      let type = entry.kind ? String(entry.kind) : undefined;\n\n      if (type === \"member\") type = \"property\";\n\n      if (type && !DEFAULT_CODEMIRROR_TYPE_ICONS.has(type)) {\n        type = undefined;\n      }\n\n      return {\n        label: entry.name,\n        type,\n        boost,\n      };\n    });\n\n  return {\n    from: word ? (word.text === \".\" ? word.to : word.from) : pos,\n    options,\n  };\n}\n"]}