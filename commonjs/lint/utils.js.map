{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../src/lint/utils.ts"],"names":[],"mappings":";;;AAAA,2CAIoB;AAGpB;;;;GAIG;AACH,SAAgB,oBAAoB,CAClC,UAA6D;IAE7D,IAAI,UAAU,CAAC,IAAI,KAAK,IAAI,EAAE;QAC5B,4BAA4B;QAC5B,OAAO,SAAS,CAAC;KAClB;IACD,QAAQ,UAAU,CAAC,QAAQ,EAAE;QAC3B,KAAK,+BAAkB,CAAC,KAAK;YAC3B,OAAO,OAAO,CAAC;QACjB,KAAK,+BAAkB,CAAC,OAAO;YAC7B,OAAO,MAAM,CAAC;QAChB,KAAK,+BAAkB,CAAC,OAAO;YAC7B,OAAO,SAAS,CAAC;QACnB,KAAK,+BAAkB,CAAC,UAAU;YAChC,OAAO,MAAM,CAAC;KACjB;AACH,CAAC;AAjBD,oDAiBC;AAED;;;;GAIG;AACH,SAAgB,wBAAwB,CACtC,UAAwB;IAExB,OAAO,CAAC,CAAC,CACP,UAAU,CAAC,IAAI;QACf,OAAO,UAAU,CAAC,KAAK,KAAK,QAAQ;QACpC,OAAO,UAAU,CAAC,MAAM,KAAK,QAAQ,CACtC,CAAC;AACJ,CAAC;AARD,4DAQC;AAED;;;;;GAKG;AACH,SAAgB,mBAAmB,CACjC,UAA6C;IAE7C,IAAI,OAAO,UAAU,CAAC,WAAW,KAAK,QAAQ,EAAE;QAC9C,OAAO,UAAU,CAAC,WAAW,CAAC;KAC/B;IACD,+BAA+B;IAC/B,OAAO,UAAU,CAAC,WAAW,CAAC,WAAW,CAAC;AAC5C,CAAC;AARD,kDAQC;AAED;;;;GAIG;AACH,SAAgB,uBAAuB,CAAC,CAAyB;IAC/D,mEAAmE;IACnE,iCAAiC;IACjC,MAAM,KAAK,GAAG,CAAC,CAAC,KAAK,CAAC;IACtB,MAAM,OAAO,GAAG,mBAAmB,CAAC,CAAC,CAAC,CAAC;IAEvC,OAAO;QACL,IAAI,EAAE,KAAK;QACX,EAAE,EAAE,KAAK,GAAG,CAAC,CAAC,MAAM;QACpB,OAAO,EAAE,OAAO;QAChB,QAAQ,EAAE,oBAAoB,CAAC,CAAC,CAAC;KAClC,CAAC;AACJ,CAAC;AAZD,0DAYC","sourcesContent":["import {\n  type Diagnostic as TSDiagnostic,\n  type DiagnosticWithLocation,\n  DiagnosticCategory,\n} from \"typescript\";\nimport { type Diagnostic } from \"@codemirror/lint\";\n\n/**\n * TypeScript has a set of diagnostic categories,\n * which maps roughly onto CodeMirror's categories.\n * Here, we do the mapping.\n */\nexport function tsCategoryToSeverity(\n  diagnostic: Pick<DiagnosticWithLocation, \"category\" | \"code\">,\n): Diagnostic[\"severity\"] {\n  if (diagnostic.code === 7027) {\n    // Unreachable code detected\n    return \"warning\";\n  }\n  switch (diagnostic.category) {\n    case DiagnosticCategory.Error:\n      return \"error\";\n    case DiagnosticCategory.Message:\n      return \"info\";\n    case DiagnosticCategory.Warning:\n      return \"warning\";\n    case DiagnosticCategory.Suggestion:\n      return \"info\";\n  }\n}\n\n/**\n * Not all TypeScript diagnostic relate to specific\n * ranges in source code: here we filter for those that\n * do.\n */\nexport function isDiagnosticWithLocation(\n  diagnostic: TSDiagnostic,\n): diagnostic is DiagnosticWithLocation {\n  return !!(\n    diagnostic.file &&\n    typeof diagnostic.start === \"number\" &&\n    typeof diagnostic.length === \"number\"\n  );\n}\n\n/**\n * Get the message for a diagnostic. TypeScript\n * is kind of weird: messageText might have the message,\n * or a pointer to the message. This follows the chain\n * to get a string, regardless of which case we're in.\n */\nexport function tsDiagnosticMessage(\n  diagnostic: Pick<TSDiagnostic, \"messageText\">,\n): string {\n  if (typeof diagnostic.messageText === \"string\") {\n    return diagnostic.messageText;\n  }\n  // TODO: go through linked list\n  return diagnostic.messageText.messageText;\n}\n\n/**\n * TypeScript and CodeMirror have slightly different\n * ways of representing diagnostics. This converts\n * from one to the other.\n */\nexport function convertTSDiagnosticToCM(d: DiagnosticWithLocation): Diagnostic {\n  // We add some code at the end of the document, but we can't have a\n  // diagnostic in an invalid range\n  const start = d.start;\n  const message = tsDiagnosticMessage(d);\n\n  return {\n    from: start,\n    to: start + d.length,\n    message: message,\n    severity: tsCategoryToSeverity(d),\n  };\n}\n"]}